<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Earth with Day Slider, Moon, Sun/Moon Positions, Shadow & Zoom</title> <style>
        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: #000;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden; /* Prevent scrollbars from appearing due to canvas/controls */
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        canvas {
            display: block; /* Remove extra space below canvas */
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(40, 40, 60, 0.85); /* Darker, slightly transparent background */
            padding: 15px;
            border-radius: 12px; /* Softer rounded corners */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3); /* More pronounced shadow */
            border: 1px solid rgba(255, 255, 255, 0.2); /* Subtle border */
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 12px; /* Space between control groups */
        }
        #controls label {
            font-size: 0.9em;
            margin-bottom: 3px;
        }
        #controls input[type="date"],
        #controls input[type="range"],
        #controls button {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #555; /* Slightly lighter border for inputs */
            background-color: #333; /* Dark input background */
            color: #fff;
            font-size: 0.9em;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #controls button:hover {
            background-color: #444; /* Darker hover for buttons */
        }
        #controls input[type="range"] {
            width: 150px; /* Fixed width for sliders */
        }
        #timeValue, #tileZoomValue, #dayOfYearValue { /* Added dayOfYearValue */
            font-size: 0.9em;
            margin-left: 8px; 
            min-width: 45px; /* Ensure consistent width for value displays */
            display: inline-block;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .button-group {
            display: flex;
            gap: 8px;
        }
        #messageBox {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 100, 100, 0.9); /* Default to error-like color, will be changed by JS */
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 1000;
            display: none; /* Hidden by default */
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-size: 0.9em;
            text-align: center;
        }
        /* Style for Celestial Point Display */
        #celestialInfo { 
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(40, 40, 60, 0.85);
            padding: 10px 15px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
            font-size: 0.9em;
            line-height: 1.4; 
            text-align: right;
            display: none; /* Hidden initially */
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="canvas-container">
        </div>
    <div id="controls">
        <div class="control-group">
            <label>Camera Zoom:</label>
            <div class="button-group">
                <button id="zoomInBtn">+</button>
                <button id="zoomOutBtn">-</button>
            </div>
        </div>
        <div class="control-group">
            <label for="datePicker">Date:</label>
            <input type="date" id="datePicker">
        </div>
         <div class="control-group">
            <label for="dayOfYearSlider">Day of Year:</label>
            <div>
                <input type="range" id="dayOfYearSlider" min="1" max="366" value="1"> <span id="dayOfYearValue">1</span>
            </div>
        </div>
        <div class="control-group">
            <label for="timeSlider">Time (UTC):</label>
            <div>
                <input type="range" id="timeSlider" min="0" max="1439" value="720">
                <span id="timeValue">12:00</span>
            </div>
        </div>
        <div class="control-group">
            <label for="tileZoomSlider">Map Tile Zoom (z):</label>
            <div>
                <input type="range" id="tileZoomSlider" min="3" max="6" value="3">
                <span id="tileZoomValue">3</span>
            </div>
        </div>
    </div>

    <div id="celestialInfo">Calculating...</div>
    <div id="messageBox"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Global Variables ---
        let scene, camera, renderer, earthMesh, sunLight, controls, moonMesh, moonProjectionMesh;
        let sunProjectionMesh; // Mesh to show subsolar point
        let northPoleMeshGlobal, southPoleMeshGlobal; // Meshes for polar caps
        let currentTileZoomLevel = 4; // Initial tile zoom level for map
        let moonShadowMesh; // Mesh for the Moon's umbra (shadow)

        // --- Constants ---
        const EARTH_RADIUS = 5; // Arbitrary radius for Earth in scene units
        const MOON_DISTANCE = 60.3; // Actual average distance from Earth to Moon in Earth radius;
        const SUN_DISTANCE = 23460; // Actual average distance from Earth to Sun in Earth radius
        const MOON_RADIUS = EARTH_RADIUS / 3.67; // Relative Moon radius
        const VISUAL_MOON_DISTANCE_FACTOR = 15; // Visual distance of Moon from Earth (not to scale for orbit, but for visuals)
                                                // Actual average distance is ~60.3 Earth radii.
                                                // Smaller values bring Moon closer for easier viewing.

        // Constants for Moon's Umbra (shadow)
        const MOON_SHADOW_COLOR = 0x4A2A00; // Dark orange for the shadow
        const MOON_SHADOW_OPACITY = 0.75;   // Opacity of the shadow
        const ECLIPSE_UMBRA_RADIUS_ON_EARTH_SCENE_UNITS = 0.35; // Visual radius of the umbra on Earth in scene units.
                                                              // Actual umbra size varies, this is for visual representation.
        const ECLIPSE_THRESHOLD_ANGLE_RAD = (0.35 * Math.PI / 180); // Max angular separation (Sun-Earth-Moon) to show umbra (degrees to radians)
                                                                   // A small angle means Sun and Moon must be closely aligned.

        const TILE_SERVER_URL_SCHEME = 'https://tile.openstreetmap.org/{z}/{x}/{y}.png'; // URL scheme for map tiles
        const TILE_CANVAS_SIZE = 4096; // Resolution of the canvas used to stitch map tiles

        // DOM Elements
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const datePicker = document.getElementById('datePicker');
        const dayOfYearSlider = document.getElementById('dayOfYearSlider'); 
        const dayOfYearValueDisplay = document.getElementById('dayOfYearValue'); 
        const timeSlider = document.getElementById('timeSlider');
        const timeValueDisplay = document.getElementById('timeValue');
        const tileZoomSlider = document.getElementById('tileZoomSlider');
        const tileZoomValueDisplay = document.getElementById('tileZoomValue');
        const canvasContainer = document.getElementById('canvas-container');
        const messageBox = document.getElementById('messageBox');
        const celestialInfoDiv = document.getElementById('celestialInfo'); 

        // --- Helper Functions ---
        // Checks if a given year is a leap year
        function isLeap(year) {
            return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        }

        // Gets the day number (1-365 or 1-366) for a given UTC date
        function getDayOfYear(date) {
            const start = new Date(Date.UTC(date.getUTCFullYear(), 0, 0)); // Start of the year
            const diff = date.getTime() - start.getTime(); // Difference in milliseconds
            const oneDay = 1000 * 60 * 60 * 24; // Milliseconds in a day
            return Math.floor(diff / oneDay);
        }

        // Gets a UTC date from a year and a day number
        function getDateFromDay(year, day) {
            const date = new Date(Date.UTC(year, 0)); // Initialize to Jan 1st of the year
            return new Date(date.setUTCDate(day)); // Set the day of the year
        }

        // Formats a Date object into YYYY-MM-DD string
        function formatDate(date) {
            const yyyy = date.getUTCFullYear();
            const mm = String(date.getUTCMonth() + 1).padStart(2, '0'); // Months are 0-indexed
            const dd = String(date.getUTCDate()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd}`;
        }

        // --- Initialization ---
        async function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510); // Dark space background

            // Camera setup
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, EARTH_RADIUS * 0.5, EARTH_RADIUS * 5); // Initial camera position
            camera.lookAt(0, 0, 0); // Look at the center of the scene (Earth)

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // For sharp rendering on high DPI screens
            canvasContainer.appendChild(renderer.domElement); // Add canvas to the container

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x606060, 1.5); // Soft ambient light
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 3.0); // Main light source (Sun)
            scene.add(sunLight);

            // --- Sun Projection Circle (Subsolar Point Marker) ---
            const sunProjGeom = new THREE.CircleGeometry(EARTH_RADIUS * 0.008, 32); // Small circle
            const sunProjMat = new THREE.MeshBasicMaterial({ color: 0xFFFF00, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
            sunProjectionMesh = new THREE.Mesh(sunProjGeom, sunProjMat);
            sunProjectionMesh.visible = false; // Initially hidden
            scene.add(sunProjectionMesh);

            // --- Moon Projection Circle (Sublunar Point Marker) ---
            const moonProjGeom = new THREE.CircleGeometry(EARTH_RADIUS * 0.008, 32); // Small circle
            const moonProjMat = new THREE.MeshBasicMaterial({ color: 0xAAAAFF, transparent: true, opacity: 0.6, side: THREE.DoubleSide }); // Light blue/grey
            moonProjectionMesh = new THREE.Mesh(moonProjGeom, moonProjMat);
            moonProjectionMesh.visible = false; // Initially hidden
            scene.add(moonProjectionMesh);


            // --- Moon ---
            const moonGeometry = new THREE.SphereGeometry(MOON_RADIUS, 32, 32);
            const moonMaterial = new THREE.MeshPhongMaterial({ color: 0xaaaaaa, shininess: 5, specular: 0x111111 }); 
            moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
            scene.add(moonMesh); 

            // --- Moon Shadow (Umbra) ---
            const shadowGeometry = new THREE.CircleGeometry(ECLIPSE_UMBRA_RADIUS_ON_EARTH_SCENE_UNITS, 32);
            const shadowMaterial = new THREE.MeshBasicMaterial({
                color: MOON_SHADOW_COLOR,
                transparent: true,
                opacity: MOON_SHADOW_OPACITY,
                side: THREE.DoubleSide // Render on both sides (though only one will be visible on sphere)
            });
            moonShadowMesh = new THREE.Mesh(shadowGeometry, shadowMaterial);
            moonShadowMesh.visible = false; // Initially hidden
            scene.add(moonShadowMesh);


            // --- Earth ---
            try {
                await updateEarthTiles(currentTileZoomLevel); // Load initial map tiles
                // Initial date setup and sync
                //const today = new Date();
                const today = new Date("2026-08-12T18:02:00");
                datePicker.value = formatDate(today); 
                syncDaySliderToDate(); // Sync day slider to the initial date
                updateCelestialPositions(); // Calculate initial Sun/Moon positions
            } catch (error) {
                console.error("Error during initial scene setup:", error);
                showMessage("Failed to initialize Earth. Please refresh.", "error", 10000);
            }

            // --- Controls (OrbitControls for camera interaction) ---
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth camera movement
            controls.dampingFactor = 0.05;
            controls.minDistance = EARTH_RADIUS + 0.2; // Prevent zooming inside Earth
            controls.maxDistance = EARTH_RADIUS * 20; // Max zoom out distance
            controls.enablePan = false; // Disable panning

            // --- UI Event Listeners ---
            zoomInBtn.addEventListener('click', () => zoomCamera(0.8));
            zoomOutBtn.addEventListener('click', () => zoomCamera(1.25));
            
            datePicker.addEventListener('change', () => { // Use 'change' for date picker for better UX
                syncDaySliderToDate();
                updateCelestialPositions();
            });

            dayOfYearSlider.addEventListener('input', () => { // Use 'input' for immediate feedback from slider
                syncDateToDaySlider();
                updateCelestialPositions();
            });

            timeSlider.addEventListener('input', () => {
                const minutes = parseInt(timeSlider.value);
                const h = Math.floor(minutes / 60);
                const m = minutes % 60;
                timeValueDisplay.textContent = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
                updateCelestialPositions();
            });

            tileZoomSlider.addEventListener('input', async (event) => {
                const newZoomLevel = parseInt(event.target.value);
                tileZoomValueDisplay.textContent = newZoomLevel;
                if (newZoomLevel !== currentTileZoomLevel) {
                    currentTileZoomLevel = newZoomLevel;
                    showMessage(`Loading tiles for zoom level ${currentTileZoomLevel}... This may take a moment.`, "info", 0); // 0 duration = persistent until next message
                    await updateEarthTiles(currentTileZoomLevel);
                    updateCelestialPositions(); // Update positions as Earth texture might affect visuals
                }
            });

            window.addEventListener('resize', onWindowResize); // Handle window resizing
            animate(); // Start the animation loop
        }

        // --- Date/Day Slider Synchronization ---
        // Updates the day-of-year slider based on the date picker's value
        function syncDaySliderToDate() {
            const dateStr = datePicker.value;
            if (!dateStr) return; // Exit if date picker is empty
            const year = parseInt(dateStr.substring(0, 4));
            const month = parseInt(dateStr.substring(5, 7)) - 1; // Month is 0-indexed for Date object
            const day = parseInt(dateStr.substring(8, 10));
            const currentUtcDate = new Date(Date.UTC(year, month, day));
            
            const dayNum = getDayOfYear(currentUtcDate);
            
            // Update slider's max value based on whether it's a leap year
            dayOfYearSlider.max = isLeap(year) ? 366 : 365;
            
            dayOfYearSlider.value = dayNum;
            dayOfYearValueDisplay.textContent = dayNum;
        }

        // Updates the date picker based on the day-of-year slider's value
        function syncDateToDaySlider() {
            const dayNum = parseInt(dayOfYearSlider.value);
            const dateStr = datePicker.value; // Get current year from date picker
            let year = new Date().getUTCFullYear(); // Default to current year if picker is empty
             if (dateStr) {
                 year = parseInt(dateStr.substring(0, 4));
             } else {
                 // If date picker was empty, update it with the first day of current year
                 datePicker.value = formatDate(getDateFromDay(year, 1));
             }

            // Update slider's max value based on year (in case it changed via date picker)
            dayOfYearSlider.max = isLeap(year) ? 366 : 365;
            
            const newDate = getDateFromDay(year, dayNum);
            datePicker.value = formatDate(newDate); // Update date picker
            dayOfYearValueDisplay.textContent = dayNum; // Update slider display
        }


        // --- Mercator Tile to Geographic Coordinate Helpers ---
        // Converts tile X coordinate and zoom level to longitude
        function tile2lon(x, z) { return x / Math.pow(2, z) * 360 - 180; }
        // Converts tile Y coordinate and zoom level to latitude
        function tile2lat(y, z) { const n = Math.PI - 2 * Math.PI * y / Math.pow(2, z); return 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))); }
        // Gets the geographic bounding box for a given map tile
        function getTileGeoBounds(tileX, tileY, zoom) {
            const lon1 = tile2lon(tileX, zoom); const lat1 = tile2lat(tileY, zoom);
            const lon2 = tile2lon(tileX + 1, zoom); const lat2 = tile2lat(tileY + 1, zoom);
            return { minLon: lon1, maxLon: lon2, minLat: lat2, maxLat: lat1 }; // Note: lat2 is minLat, lat1 is maxLat
        }

        // --- Earth Tile Update ---
        // Loads map tiles and stitches them onto a canvas, then applies it as a texture to the Earth mesh
        async function updateEarthTiles(zoomLevel) {
             // Clean up old Earth mesh and its resources if they exist
             if (earthMesh) {
                scene.remove(earthMesh);
                if (earthMesh.geometry) earthMesh.geometry.dispose();
                if (earthMesh.material && earthMesh.material.map) earthMesh.material.map.dispose();
                if (earthMesh.material) earthMesh.material.dispose();
                earthMesh = null;
            }
            // Clean up polar caps if they exist
            if(northPoleMeshGlobal && northPoleMeshGlobal.parent) northPoleMeshGlobal.parent.remove(northPoleMeshGlobal);
            if(southPoleMeshGlobal && southPoleMeshGlobal.parent) southPoleMeshGlobal.parent.remove(southPoleMeshGlobal);
            northPoleMeshGlobal = null; southPoleMeshGlobal = null;

            const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 128, 128); // Higher segments for smoother sphere
            const numTilesPerDimension = Math.pow(2, zoomLevel);
            const tilesToLoad = []; // Array to hold tile information for loading
            for (let y = 0; y < numTilesPerDimension; y++) { for (let x = 0; x < numTilesPerDimension; x++) { tilesToLoad.push({ z: zoomLevel, x: x, y: y }); } }

            // Create a canvas to draw the stitched tiles
            const tileCanvas = document.createElement('canvas');
            tileCanvas.width = TILE_CANVAS_SIZE; tileCanvas.height = TILE_CANVAS_SIZE;
            const ctx = tileCanvas.getContext('2d');
            ctx.fillStyle = '#102030'; // Dark blue placeholder color for empty areas
            ctx.fillRect(0, 0, tileCanvas.width, tileCanvas.height);

            const textureLoader = new THREE.TextureLoader();
            textureLoader.setCrossOrigin("anonymous"); // Important for loading cross-origin images
            let loadedCount = 0; const totalTiles = tilesToLoad.length; let progressLastShown = 0;

            // Load all tiles asynchronously
            const promises = tilesToLoad.map(tileInfo => {
                const tileUrl = TILE_SERVER_URL_SCHEME.replace('{z}', tileInfo.z).replace('{x}', tileInfo.x).replace('{y}', tileInfo.y);
                return new Promise((resolve) => {
                    textureLoader.load(tileUrl, (texture) => {
                            const image = texture.image; // The loaded image data
                            try {
                                // Calculate the drawing position and size on the main canvas based on tile's geo bounds
                                const geoBounds = getTileGeoBounds(tileInfo.x, tileInfo.y, zoomLevel);
                                const destX = ((geoBounds.minLon + 180) / 360) * TILE_CANVAS_SIZE;
                                const destMaxX = ((geoBounds.maxLon + 180) / 360) * TILE_CANVAS_SIZE;
                                const destY = ((90 - geoBounds.maxLat) / 180) * TILE_CANVAS_SIZE; // Latitude is inverted for y-coordinate
                                const destMaxY = ((90 - geoBounds.minLat) / 180) * TILE_CANVAS_SIZE;
                                const destWidth = destMaxX - destX; const destHeight = destMaxY - destY;
                                if (destWidth > 0 && destHeight > 0) { ctx.drawImage(image, 0, 0, image.width, image.height, destX, destY, destWidth, destHeight); }
                            } catch (e) { console.error(`Error processing/drawing tile ${tileUrl} to canvas:`, e); }
                            loadedCount++; const progress = Math.floor((loadedCount / totalTiles) * 100);
                            // Update progress message periodically
                            if (progress > progressLastShown + 5 || loadedCount === totalTiles) { 
                                console.log(`Loaded ${loadedCount}/${totalTiles} tiles (${progress}%) for z=${zoomLevel}`);
                                showMessage(`Loading tiles: ${progress}% complete...`, "loading", loadedCount === totalTiles ? 1000 : 0); progressLastShown = progress;
                            } resolve();
                        }, undefined, (error) => { // Error callback for textureLoader.load
                            console.error(`Failed to load tile image: ${tileUrl}`, error);
                            // Optionally draw a placeholder for the failed tile on the canvas
                            const placeholderSize = TILE_CANVAS_SIZE / numTilesPerDimension; // Approximate size
                            drawErrorPlaceholder(ctx, tileInfo.x * placeholderSize, tileInfo.y * placeholderSize, placeholderSize, zoomLevel, tileInfo.x, tileInfo.y, "LoadErr");
                            loadedCount++; const progress = Math.floor((loadedCount / totalTiles) * 100);
                             if (progress > progressLastShown + 5 || loadedCount === totalTiles) {
                                console.log(`Processed (w/error) ${loadedCount}/${totalTiles} tiles (${progress}%) for z=${zoomLevel}`);
                                showMessage(`Loading tiles (some errors): ${progress}% complete...`, "loading", loadedCount === totalTiles ? 1000 : 0); progressLastShown = progress;
                            } resolve(); // Resolve even on error to not block Promise.all
                        } ); }); });
            
            await Promise.all(promises); // Wait for all tile loading and drawing to complete
            showMessage(`All ${totalTiles} tile requests for zoom ${zoomLevel} processed.`, "info", 4000);
            
            // Create texture from the canvas and apply to Earth material
            const earthTexture = new THREE.CanvasTexture(tileCanvas);
            earthTexture.colorSpace = THREE.SRGBColorSpace; // Correct color space for textures
            earthTexture.anisotropy = renderer.capabilities.getMaxAnisotropy(); // Improves texture quality at oblique angles
            earthTexture.needsUpdate = true;
            const earthMaterial = new THREE.MeshPhongMaterial({ map: earthTexture, shininess: 10, specular: 0x101010 });
            earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
            scene.add(earthMesh);
            createPolarCaps(earthMesh); // Add polar caps to the new Earth mesh
        }
        
        // Helper to draw a placeholder on the canvas if a tile fails to load
        function drawErrorPlaceholder(context, canvasX, canvasY, size, z, tx, ty, errType = "Err") {
            // This function is a stub. For a real implementation, you might draw a colored square or text.
            console.warn(`Placeholder for error: ${errType} z${z},${tx},${ty} at approx canvas x:${canvasX}, y:${canvasY}`);
            // Example: context.fillStyle = 'red'; context.fillRect(canvasX, canvasY, size, size);
        }

        // Creates simple white circles for polar caps and adds them to the parent Earth mesh
        function createPolarCaps(parentMesh) {
            if (!parentMesh) return;
            const poleRadius = EARTH_RADIUS * 0.22; // Radius of the polar caps
            const poleSegments = 32;
            const poleMaterial = new THREE.MeshBasicMaterial({ color: 0xf0f5fa, side: THREE.DoubleSide });

            // North Pole Cap
            northPoleMeshGlobal = new THREE.Mesh(new THREE.CircleGeometry(poleRadius, poleSegments), poleMaterial);
            northPoleMeshGlobal.position.set(0, EARTH_RADIUS + 0.01, 0); // Slightly above the Earth's surface
            northPoleMeshGlobal.rotation.x = -Math.PI / 2; // Rotate to lie flat on the pole
            parentMesh.add(northPoleMeshGlobal);

            // South Pole Cap
            southPoleMeshGlobal = new THREE.Mesh(new THREE.CircleGeometry(poleRadius, poleSegments), poleMaterial);
            southPoleMeshGlobal.position.set(0, -EARTH_RADIUS - 0.01, 0); // Slightly below the Earth's surface
            southPoleMeshGlobal.rotation.x = Math.PI / 2; // Rotate to lie flat on the pole
            parentMesh.add(southPoleMeshGlobal);
        }

        // --- Astronomical Calculation Utilities ---
        // Converts a JavaScript Date object to Julian Date
        function getJulianDate(date) { return (date.getTime() / 86400000.0) + 2440587.5; }
        // Calculates Greenwich Mean Sidereal Time (GMST) in degrees
        function getGMST(jd_ut1) { // jd_ut1 is Julian Date for UT1
            const T = (jd_ut1 - 2451545.0) / 36525.0; // Time in Julian centuries since J2000.0
            // Formula for GMST (IAU 1982 model, simplified)
            let gmst = 280.46061837 + 360.98564736629 * (jd_ut1 - 2451545.0) + 0.000387933 * T * T - (T * T * T / 38710000.0);
            return (gmst % 360 + 360) % 360; // Ensure positive value in 0-360 range
        }
        
        // --- Sun Position Calculation ---
        // Calculates the subsolar point (latitude, longitude in radians) for a given UTC date
        // Based on simplified algorithms, good for visualization.
        function getSunGeographicPosition(date) {
            const jday_UT = getJulianDate(date); 
            const T = (jday_UT - 2451545.0) / 36525.0; // Julian centuries since J2000
            // Mean longitude of the Sun, corrected for aberration
            let L_deg = (280.46645 + 36000.76983 * T + 0.0003032 * T * T); L_deg = (L_deg % 360 + 360) % 360; 
            // Mean anomaly of the Sun
            let M_deg = (357.52910 + 35999.05030 * T - 0.0001559 * T * T - 0.00000048 * T * T * T); M_deg = (M_deg % 360 + 360) % 360; 
            const M_rad = M_deg * Math.PI / 180;
            // Equation of center
            const C1_coeff = (1.914602 - 0.004817 * T - 0.000014 * T * T); const C2_coeff = (0.019993 - 0.000101 * T); const C3_coeff = 0.000289;
            const C_deg = C1_coeff * Math.sin(M_rad) + C2_coeff * Math.sin(2 * M_rad) + C3_coeff * Math.sin(3 * M_rad);
            // True longitude and ecliptic latitude (assumed to be 0 for Sun)
            const lambda_true_deg = (L_deg + C_deg); const lambda_true_rad = ((lambda_true_deg % 360 + 360) % 360) * Math.PI / 180;
            // Obliquity of the ecliptic
            const epsilon_deg = (23.439291 - 0.0130042 * T - 0.00000016 * T * T + 0.000000504 * T * T * T); const epsilon_rad = epsilon_deg * Math.PI / 180;
            // Right ascension (alpha) and declination (delta)
            const alpha_rad = Math.atan2(Math.cos(epsilon_rad) * Math.sin(lambda_true_rad), Math.cos(lambda_true_rad));
            const delta_rad = Math.asin(Math.sin(epsilon_rad) * Math.sin(lambda_true_rad));
            // Subsolar latitude is the Sun's declination
            const subsolarLat_rad = delta_rad; 
            // Subsolar longitude calculation
            const gmst_deg = getGMST(jday_UT); const gmst_rad = gmst_deg * Math.PI / 180;
            let alpha_normalized_rad = alpha_rad; if (alpha_normalized_rad < 0) alpha_normalized_rad += 2 * Math.PI; // Normalize RA to 0-2PI
            let subsolarLon_rad = alpha_normalized_rad - gmst_rad; // Longitude = RA - GMST
            // Normalize longitude to -PI to +PI range
            while (subsolarLon_rad > Math.PI) subsolarLon_rad -= 2 * Math.PI; while (subsolarLon_rad < -Math.PI) subsolarLon_rad += 2 * Math.PI;
            return { latitude: subsolarLat_rad, longitude: subsolarLon_rad };
        }

        // --- Moon Position Calculation ---
        // Calculates Moon's geocentric equatorial coordinates (RA, Dec) and distance for a given UTC date
        // Based on simplified algorithms (e.g., Meeus, Astronomical Algorithms, Chapter 47 for low precision)
        function getMoonPosition(date) {
            const jday_UT = getJulianDate(date); const T = (jday_UT - 2451545.0) / 36525.0; // Julian centuries
            // Moon's mean longitude
            let L_prime_deg = (218.3164 + 481267.8813 * T); L_prime_deg = (L_prime_deg % 360 + 360) % 360;
            // Moon's mean anomaly
            let M_prime_deg = (134.9634 + 477198.8675 * T); M_prime_deg = (M_prime_deg % 360 + 360) % 360;
            // Moon's argument of latitude
            let F_deg = (93.2721 + 483202.0175 * T); F_deg = (F_deg % 360 + 360) % 360;
            // Sun's mean anomaly (needed for some perturbations)
            let M_sun_deg = (357.5291 + 35999.0503 * T); M_sun_deg = (M_sun_deg % 360 + 360) % 360;
            // Moon's mean elongation
            let D_deg = (297.8502 + 445267.1115 * T); D_deg = (D_deg % 360 + 360) % 360;
            
            // Convert to radians for trig functions
            const M_prime_rad = M_prime_deg * Math.PI / 180; const F_rad = F_deg * Math.PI / 180; const D_rad = D_deg * Math.PI / 180; const M_sun_rad = M_sun_deg * Math.PI / 180; const L_prime_rad = L_prime_deg * Math.PI / 180;
            
            // Major periodic terms for longitude (degrees)
            let sum_lon = 0; sum_lon += +6.288774 * Math.sin(M_prime_rad); sum_lon += -1.274027 * Math.sin(M_prime_rad - 2 * D_rad); sum_lon += +0.658314 * Math.sin(2 * D_rad); sum_lon += +0.213618 * Math.sin(2 * M_prime_rad); sum_lon += -0.185116 * Math.sin(M_sun_rad); sum_lon += -0.114332 * Math.sin(2 * F_rad);
            // Major periodic terms for latitude (degrees)
            let sum_lat = 0; sum_lat += +5.128122 * Math.sin(F_rad); sum_lat += +0.280602 * Math.sin(M_prime_rad + F_rad); sum_lat += +0.277693 * Math.sin(M_prime_rad - F_rad); sum_lat += +0.173237 * Math.sin(2*D_rad - F_rad);
            // Major periodic terms for distance (Earth radii)
            let sum_dist = 0; sum_dist += -0.58 * Math.cos(M_prime_rad); sum_dist += -0.16 * Math.cos(M_prime_rad - 2*D_rad); 
            
            // Ecliptic longitude, latitude, and distance
            const lambda_moon_rad = L_prime_rad + sum_lon * Math.PI / 180; const beta_moon_rad = sum_lat * Math.PI / 180; const distance_moon_ER = 60.2666 + sum_dist; // Average distance ~60.27 ER
            
            // Convert ecliptic to equatorial coordinates
            const epsilon_deg = (23.439291 - 0.0130042 * T - 0.00000016 * T * T + 0.000000504 * T * T * T); const epsilon_rad = epsilon_deg * Math.PI / 180; // Obliquity
            const sin_epsilon = Math.sin(epsilon_rad); const cos_epsilon = Math.cos(epsilon_rad); const sin_lambda = Math.sin(lambda_moon_rad); const cos_lambda = Math.cos(lambda_moon_rad); const sin_beta = Math.sin(beta_moon_rad); const cos_beta = Math.cos(beta_moon_rad);
            // Right ascension (alpha_m) and declination (delta_m)
            const alpha_m_rad = Math.atan2(sin_lambda * cos_epsilon - Math.tan(beta_moon_rad) * sin_epsilon, cos_lambda);
            const delta_m_rad = Math.asin(sin_beta * cos_epsilon + cos_beta * sin_epsilon * sin_lambda);
            let alpha_m_normalized_rad = alpha_m_rad; if (alpha_m_normalized_rad < 0) alpha_m_normalized_rad += 2 * Math.PI; // Normalize RA
            
            return { rightAscension: alpha_m_normalized_rad, declination: delta_m_rad, distance: distance_moon_ER };
        }

        // --- Update Sun and Moon Positions & Info Display ---
        function updateCelestialPositions() {
            if (!datePicker.value || !earthMesh) return; // Ensure necessary elements are available
            const dateStr = datePicker.value;
            const timeMinutes = parseInt(timeSlider.value, 10);
            const hours = Math.floor(timeMinutes / 60);
            const minutes = timeMinutes % 60;
            // Create current UTC date object based on UI controls
            const currentDate = new Date(Date.UTC(
                parseInt(dateStr.substring(0, 4)), parseInt(dateStr.substring(5, 7)) - 1, parseInt(dateStr.substring(8, 10)),
                hours, minutes
            ));
            
            // --- Update Sun ---
            const subsolarPoint = getSunGeographicPosition(currentDate);
            let subsolarLatDeg = NaN;
            let subsolarLonDeg = NaN;
            let subsolarVec = new THREE.Vector3(1, 0, 0); // Default vector, will be updated

             if (subsolarPoint.error) { // Should not happen with current simplified model
                 console.error("Cannot update sun projection due to error in getSunGeographicPosition.");
                 if (sunProjectionMesh) sunProjectionMesh.visible = false; 
             } else {
                 subsolarLatDeg = subsolarPoint.latitude * 180 / Math.PI;
                 subsolarLonDeg = subsolarPoint.longitude * 180 / Math.PI;
                 const sunDirection = new THREE.Vector3();
                 // Vector from Earth's center TO the subsolar point (direction of Sun)
                 sunDirection.setFromSphericalCoords(1, Math.PI/2 - subsolarPoint.latitude,  Math.PI/2 + subsolarPoint.longitude);
                 subsolarVec.copy(sunDirection); // Store normalized vector to Sun
                 // Sun light position is far away in the direction of the sun
                 sunLight.position.copy(sunDirection.clone().multiplyScalar(EARTH_RADIUS * 20)); // Position light source
                 sunLight.target = earthMesh; // Ensure light points at Earth

                 // Update subsolar point marker
                 if (sunProjectionMesh) {
                     const projectionPosition = new THREE.Vector3();
                     projectionPosition.setFromSphericalCoords(EARTH_RADIUS + 0.03, // Slightly above surface
                            Math.PI / 2 - subsolarPoint.latitude, // Colatitude
                            Math.PI / 2 + subsolarPoint.longitude); // Azimuthal angle (Longitude adjusted for Three.js)
                     sunProjectionMesh.position.copy(projectionPosition);
                     sunProjectionMesh.lookAt(earthMesh.position); // Orient marker to face outwards
                     sunProjectionMesh.visible = true;
                 }
             }

            // --- Update Moon ---
            let sublunarLatDeg = NaN;
            let sublunarLonDeg = NaN;
            let sublunarLatRad = NaN;
            let sublunarLonRad = NaN;
            let eclipseLatDeg = NaN;
            let eclipseLonDeg = NaN;
            let moonCartesian = new THREE.Vector3(); // Cartesian position of Moon in scene
            let earthToMoonVecNormalized = new THREE.Vector3(0, 1, 0); // Default, will be updated

            if (moonMesh) {
                const moonPosGeo = getMoonPosition(currentDate); // Get Moon's RA/Dec
                const visualMoonDistance = EARTH_RADIUS * VISUAL_MOON_DISTANCE_FACTOR; // Visual distance for display
                
                // Convert Moon's RA/Dec to sublunar lat/lon
                const jday_UT = getJulianDate(currentDate);
                const gmst_deg = getGMST(jday_UT);
                const gmst_rad = gmst_deg * Math.PI / 180;
                
                sublunarLatRad = moonPosGeo.declination; // Sublunar latitude is Moon's declination
                sublunarLonRad = moonPosGeo.rightAscension - gmst_rad; // Sublunar longitude = RA - GMST
                
                // Normalize sublunar longitude to -PI to +PI
                while (sublunarLonRad > Math.PI) sublunarLonRad -= 2 * Math.PI;
                while (sublunarLonRad < -Math.PI) sublunarLonRad += 2 * Math.PI;

                sublunarLatDeg = sublunarLatRad * 180 / Math.PI; 
                sublunarLonDeg = sublunarLonRad * 180 / Math.PI;

                // Calculate Moon's Cartesian position for visualization
                moonCartesian.setFromSphericalCoords(
                    visualMoonDistance,
                    Math.PI / 2 - moonPosGeo.declination, // Colatitude
                    Math.PI / 2  + sublunarLonRad         // Azimuthal angle (Longitude adjusted for scene)
                );
                moonMesh.position.copy(moonCartesian);
                moonMesh.lookAt(earthMesh.position); // Moon always faces Earth (tidally locked visual approximation)
                earthToMoonVecNormalized.copy(moonCartesian).normalize(); // Normalized vector from Earth to Moon


                // Update Moon Projection Circle (Sublunar Point Marker)
                if (moonProjectionMesh && !isNaN(sublunarLatRad) && !isNaN(sublunarLonRad)) {
                    const moonProjectionPosition = new THREE.Vector3();
                    moonProjectionPosition.setFromSphericalCoords(
                        EARTH_RADIUS + 0.031, // Slightly above surface, distinct from sun marker
                        Math.PI / 2 - sublunarLatRad, // Colatitude
                        Math.PI / 2  + sublunarLonRad  // Azimuth
                    );
                    moonProjectionMesh.position.copy(moonProjectionPosition);
                    moonProjectionMesh.lookAt(earthMesh.position); 
                    moonProjectionMesh.visible = true;
                } else if (moonProjectionMesh) {
                     moonProjectionMesh.visible = false;
                }

            } else { // If no moonMesh, hide projection
                 if (moonProjectionMesh) moonProjectionMesh.visible = false;
            }

            // --- Moon Shadow (Umbra) Logic ---
            if (moonShadowMesh && moonMesh && !subsolarPoint.error && earthMesh && !isNaN(sublunarLatRad) && !isNaN(sublunarLonRad)) {
                // earthToMoonVecNormalized is the normalized vector from Earth center to Moon
                // subsolarVec is the normalized vector from Earth center to Sun
                
                const angleSunMoon = subsolarVec.angleTo(earthToMoonVecNormalized); // Angle between Sun and Moon vectors as seen from Earth's center

                // Check if Moon is roughly between Earth and Sun
                if (true) { //angleSunMoon < ECLIPSE_THRESHOLD_ANGLE_RAD) {
                    const aLatRad = sublunarLatRad - subsolarPoint.latitude;
                    const aLonRad = sublunarLonRad - subsolarPoint.longitude;
                    const bLonRad = Math.atan(Math.sin(aLonRad)/(SUN_DISTANCE/MOON_DISTANCE - Math.cos(aLonRad)));
                    const bLatRad = Math.atan(Math.sin(aLatRad)/(SUN_DISTANCE/MOON_DISTANCE - Math.cos(aLatRad)));
                    const cLatRad = Math.asin(SUN_DISTANCE*(1-1/SUN_DISTANCE)*Math.tan(bLatRad));
                    const cLonRad = Math.asin(SUN_DISTANCE*(1-1/SUN_DISTANCE)*Math.tan(bLonRad));
                    eclipseLatDeg = cLatRad * 180 / Math.PI;
                    eclipseLonDeg = cLonRad * 180 / Math.PI;
                    const shadowPosition = new THREE.Vector3();
                    // Position shadow at sublunar point on Earth's surface
                    shadowPosition.setFromSphericalCoords(
                        EARTH_RADIUS + 0.045, // Slightly above surface to avoid z-fighting, below other markers
                        Math.PI / 2 - cLatRad, // Colatitude for shadow
                        Math.PI / 2 + cLonRad  // Azimuth for shadow
                    );
                    moonShadowMesh.position.copy(shadowPosition);
                    moonShadowMesh.lookAt(earthMesh.position); // Orient shadow to lie flat on sphere
                    moonShadowMesh.visible = true;
                } else {
                    moonShadowMesh.visible = false; // Moon not aligned for eclipse
                }
            } else if (moonShadowMesh) {
                moonShadowMesh.visible = false; // Hide shadow if conditions not met
            }


            // Update the celestial info display
            if (celestialInfoDiv) {
                let infoText = "";
                if (!isNaN(subsolarLatDeg)) {
                    infoText += `Subsolar: ${subsolarLatDeg.toFixed(2)}° Lat, ${subsolarLonDeg.toFixed(2)}° Lon`;
                } else {
                    infoText += "Subsolar: Error";
                }
                infoText += "<br>"; 
                 if (!isNaN(sublunarLatDeg)) {
                    infoText += `Sublunar: ${sublunarLatDeg.toFixed(2)}° Lat, ${sublunarLonDeg.toFixed(2)}° Lon`;
                } else {
                    infoText += "Sublunar: Calculating..."; 
                }
                infoText += "<br>"; 
                 if (!isNaN(eclipseLatDeg)) {
                    infoText += `Eclipse: ${eclipseLatDeg.toFixed(2)}° Lat, ${eclipseLonDeg.toFixed(2)}° Lon`;
                } else {
                    infoText += "Eclipse: -"; 
                }
                celestialInfoDiv.innerHTML = infoText;
                celestialInfoDiv.style.display = 'block'; 
            }
        }

        // Zooms the camera in or out by a given factor
        function zoomCamera(factor) {
            const currentDistance = camera.position.length();
            let newDistance = currentDistance * factor;
            // Clamp new distance to min/max zoom limits
            newDistance = Math.max(controls.minDistance, Math.min(controls.maxDistance, newDistance));
            camera.position.setLength(newDistance);
        }

        // Handles window resize events to update camera aspect ratio and renderer size
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Displays a message in the message box
        let messageTimeout; // Timeout ID for clearing messages
        function showMessage(text, type = "info", duration = 3000) {
            messageBox.textContent = text;
            // Set background color based on message type
            if (type === "error") messageBox.style.backgroundColor = "rgba(200, 50, 50, 0.9)";
            else if (type === "loading") messageBox.style.backgroundColor = "rgba(50, 50, 150, 0.9)";
            else messageBox.style.backgroundColor = "rgba(50, 150, 50, 0.9)"; // Default info color
            
            messageBox.style.display = "block";
            clearTimeout(messageTimeout); // Clear any existing message timeout
            if (duration > 0) { // If duration is 0, message stays until replaced
                messageTimeout = setTimeout(() => { messageBox.style.display = "none"; }, duration);
            }
        }

        // Main animation loop
        function animate() {
            requestAnimationFrame(animate); // Request next frame
            controls.update(); // Update orbit controls (for damping)
            renderer.render(scene, camera); // Render the scene
        }

        // Ensure init() is called after the DOM is fully loaded
        if (document.readyState === 'loading') {  // Still loading
            document.addEventListener('DOMContentLoaded', init);
        } else {  // `DOMContentLoaded` has already fired
            init();
        }

    </script>
</body>
</html>
